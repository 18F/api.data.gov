#!/usr/bin/env ruby

# A little helper script for bulk registering and deregistering a specific
# instance from all our different ELBs. This can be handy to take an instance
# out of service from all related ELBs during maintenance.

require "aws-sdk"
require "trollop"

opts = Trollop::options do
  opt :region, "AWS region to operate in", :type => :string, :default => "us-east-1"
  opt :register, "Register instance named", :type => :string
  opt :deregister, "Deregister instance named", :type => :string
end

if(!opts[:register] && !opts[:deregister])
  puts "ERROR: You must specify either the --register or --deregister flag."
  exit 1
end

if(opts[:register] && opts[:deregister])
  puts "ERROR: You cannot use both --register and --deregister flags at the same time."
  exit 1
end

credentials = Aws::SharedCredentials.new(:profile_name => "apidatagov")
ec2_client = Aws::EC2::Client.new(:credentials => credentials, :region => opts[:region])
elb_client = Aws::ElasticLoadBalancing::Client.new(:credentials => credentials, :region => opts[:region])

change_instance_name = opts[:register] || opts[:deregister]
change_instance_id = nil
ec2_client.describe_instances({
  :filters => [
    {
      :name => "tag:Name",
      :values => [change_instance_name],
    }
  ]
}).each do |response|
  if(response.reservations.length == 0 || response.reservations.first.instances.length == 0)
    puts "ERROR: No instances found for name #{change_instance_name.inspect}"
    exit 1
  elsif(response.reservations.length > 1 || response.reservations.first.instances.length > 1)
    puts "ERROR: Multiple instances found for name #{change_instance_name.inspect}"
    exit 1
  end

  change_instance_id = response.reservations.first.instances.first.instance_id
end

if(!change_instance_id)
  puts "ERROR: Could not determine instance id for instance name #{change_instance_name.inspect}"
  exit 1
end

elbs = {}
elb_client.describe_load_balancers.each do |response|
  response.data.load_balancer_descriptions.each do |elb|
    next if(elb.load_balancer_name =~ /stage/)

    elbs[elb.load_balancer_name] = []

    instances = elb_client.describe_instance_health(:load_balancer_name => elb.load_balancer_name)
    instances.each do |instance|
      instance.data.instance_states.each do |instance_state|
        if(instance_state.state == "InService")
          elbs[elb.load_balancer_name] << instance_state.instance_id
          elbs[elb.load_balancer_name].sort!
        end
      end
    end
  end
end

elb_active_instances = elbs.values
if(elb_active_instances.uniq.length != 1)
  puts "ERROR: ELBs not in consistent state. One or more ELBs have different active instances than the others. Unable to continue."
  puts elbs.inspect
  exit 1
end

if(opts[:deregister])
  active_instances = elb_active_instances.first
  if(active_instances.length < 2)
    puts "ERROR: To deregister an instance, there must be at least one other active instance. Unable to continue."
    puts elbs.inspect
    exit 1
  end

  if(!active_instances.include?(change_instance_id))
    puts "ERROR: ELBs did not contain the instance #{change_instance_name.inspect} (#{change_instance_id}) as an active instance. Unable to continue."
    puts elbs.inspect
    exit 1
  end
end

elbs.each do |load_balancer_name, active_instances|
  if(opts[:deregister])
    puts "Deregistering #{change_instance_name.inspect} (#{change_instance_id}) from ELB #{load_balancer_name}"
    elb_client.deregister_instances_from_load_balancer({
      :load_balancer_name => load_balancer_name,
      :instances => [{ :instance_id => change_instance_id }],
    })
  elsif(opts[:register])
    puts "Registering #{change_instance_name.inspect} (#{change_instance_id}) from ELB #{load_balancer_name}"
    elb_client.register_instances_with_load_balancer({
      :load_balancer_name => load_balancer_name,
      :instances => [{ :instance_id => change_instance_id }],
    })
  end
end
